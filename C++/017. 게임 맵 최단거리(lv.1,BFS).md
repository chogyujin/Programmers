https://school.programmers.co.kr/learn/courses/30/lessons/1844#qna 
  
전형적인 BFS문제. 효율성테스트를하기 때문에 DFS로는 한계가 있다.

```C++
```


<효율성 통과 못한 DFS>
```C++
#include<vector>
using namespace std;
int dy[] = {-1,0,1,0};
int dx[] = {0,1,0,-1};
bool ch[101][101]= {false,};
int answer = 1999999999;
void dfs(vector<vector<int>> maps,int cnt,int y,int x){
    if(answer<cnt) return;
    if(y==maps.size()-1 && x==maps[0].size()-1){
        answer = answer<cnt?answer:cnt;
        return;
    }
    for(int i=0;i<4;i++){
        int nx = x+dx[i];
        int ny = y+dy[i];
        if(nx>=0&&ny>=0&&ny<maps.size()&&nx<maps[0].size()
          &&!ch[ny][nx]&&maps[ny][nx]!=0){
            ch[ny][nx] = true;
            dfs(maps,cnt+1,ny,nx);
            ch[ny][nx] = false;
        }
    }
}
int solution(vector<vector<int> > maps)
{
    ch[0][0] = true;
    dfs(maps,1,0,0);
    if(answer==1999999999) answer = -1;
    return answer;
}
```
